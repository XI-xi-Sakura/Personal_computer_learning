## TCP协议

TCP全称为"传输控制协议(TransmissionControl Protocol"). 人如其名, **要对数据的传输进行一个详细的控制**;

## TCP协议段格式
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/55dca711c0d44fe684989ff660b3d2b9.png)
- 源、目的端口号：表示数据从哪个进程来，到哪个进程去。
- 32位序号、确认序号
-  4位TCP报头长度:表示该TCP头部有多少个32位bit(有多少个4字节);所以TCP头部最大长度是15*4=60。
	- 4位首部长度，是有基本计算单位的（4字节）， 报头长度[20,60]
- 6位标志位:
	- URG: 紧急指针是否有效
	- ACK: 确认号是否有效
	- PSH: 提示接收端应用程序立刻从TCP缓冲区把数据读走
	- RST: 对方要求重新建立连接;我们把携带RST标识的称为复位报文段
	- SYN: 请求建立连接;我们把携带SYN标识的称为同步报文段
	- FIN: 通知对方,本端要关闭了,我们称携带FIN标识的为结束报文段

- 16位窗口大小
	- 就是接收缓冲区的剩余空间大小，通信双方都应该填写自己接收缓冲区的剩余空间的大小（要把自己的接收能力通知给对方）
- 16位校验和:发送端填充,CRC校验.接收端校验不通过,则认为数据有问题.此处的检验和不光包含TCP首部,也包含TCP数据部分.
- 16位紧急指针:标识哪部分数据是紧急数据;
- 40字节头部选项，TCP扩展功能

TCP是如何解包的？
- 读取前20位字节获得基本报头，然后获取4位首部长度，获取完整报文。

TCP是如何分用的?
- 16位目的端口

## 确认应答(ACK)机制
可靠性：理解确认应答

真实的TCP：直接发送一批信息，并且给各个报文带上编号（序列号），从而完整对报文是否接受的确认
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/8742830cc4384560a8d1635c0ce3b8c1.png)
 TCP将每个字节的数据都进行了编号.即为**序列号**.
 确认序号=序号+1；表示序号之前的消息一全部收到
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ea85f227c3424c0781307ffb5d210830.png)
每一个ACK都带有对应的确认序列号,意思是告诉发送者,我已经收到了哪些数据;下一次你从哪里开始发.

> 注意：报文如果是乱序的，也是不可靠的表现，所以序号的意义，也是为了让报文有序到达。

- 请求：报头+数据
- 确认应答：报头

>为什么要有两个序号?
>TCP报文，在很大概率上，既是应答，又是数据！（捎带应答机制）

## 超时重传机制
TCP丢包问题：
- 数据丢了
- 应答丢了

所以：


- 主机A发送数据给B之后,可能因为网络拥堵等原因,数据无法到达主机B;
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/287e0cd626624f519531da8618ec811d.png)
- 如果主机A在一个**特定时间间隔**内没有收到B发来的确认应答,就会进行重发;
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9fe7865d870743c6b0f01ca109c41684.png)

因此主机B会收到很多重复数据.那么TCP协议需要能够识别出那些包是重复的包,并且把重复的丢弃掉.
这时候我们可以利用前面提到的序列号,就可以很容易做到去重的效果.


>那么,如果超时的时间如何确定?
>
>- 最理想的情况下,找到一个最小的时间,保证"确认应答一定能在这个时间内返回".
>- 但是这个时间的长短,随着网络环境的不同,是有差异的.
>- 如果超时时间设的太长,会影响整体的重传效率;
>- 如果超时时间设的太短,有可能会频繁发送重复的包

TCP为了保证无论在任何环境下都能比较高性能的通信,因此会动态计算这个最大超时时间.
 - Linux中(BSDUnix和Windows也是如此),超时以500ms为一个单位进行控制, 每次判定超时重发的超时时间都是500ms的整数倍.
 - 如果重发一次之后,仍然得不到应答,等待2*500ms后再进行重传.
 - 如果仍然得不到应答,等待4*500ms进行重传.依次类推,以指数形式递增.
 - 累计到一定的重传次数,TCP认为网络或者对端主机出现异常,强制关闭连接.


这里我们要明确：
客户端是无法知道因为何种原因导致自己没有收到来自服务端的确认应答，所以处理方法仍是超时重传。





## 连接管理机制！！！
- 6位标志位:
	
	- ACK: 确认号是否有效
	
	- SYN: 请求建立连接;我们把携带SYN标识的称为同步报文段
	- FIN: 通知对方,本端要关闭了,我们称携带FIN标识的为结束报文段
- 为什么要有什么多的标志位？
	- TCP报文=报头+有效载荷
	- 服务器操作系统，收到TCP的报文是有种类的，这就要求能够区分出报文的不同种类型，区分报文类型！
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e0f36d309bfa41f7a5ad570631298e46.png)

在正常情况下,TCP要经过三次握手建立连接,四次挥手断开连接

服务端状态转化:


- [`CLOSED`->`LISTEN`]服务器端调用`listen`后进入`LISTEN`状态,等待客户端连接;
 -  [`LISTEN`->`SYN_RCVD`] 一旦监听到连接请求(同步报文段),就将该连接放入内核等待队列中,并向客户端发送`SYN`确认报文.
 - [`SYN_RCVD`->`ESTABLISHED`] 服务端一旦收到客户端的确认报文,就进入`ESTABLISHED`状态, 可以进行读写数据了.
 - [`ESTABLISHED`->`CLOSE_WAIT`] 当客户端主动关闭连接(调用close),服务器会收到结束报文段,服务器返回确认报文段并进入`CLOSE_WAIT`;
 -  [`CLOSE_WAIT`->`LAST_ACK`] 进入`CLOSE_WAIT`后说明服务器准备关闭连接(需要处理完之前的数据);当服务器真正调用`close`关闭连接时,会向客户端发送FIN, 此时服务器进入`LAST_ACK`状态,等待最后一个`ACK`到来(这个ACK是客户端确认收到了FIN)
 - [`LAST_ACK`->`CLOSED`]服务器收到了对`FIN`的`ACK`,彻底关闭连接


客户端状态转化：
- `CLOSED`->`SYN_SENT`]客户端调用`connect`,发送同步报文段;
 - [`SYN_SENT`->`ESTABLISHED`] connect调用成功, 则进`ESTABLISHED`状态, 开始读写数据;
 - [`ESTABLISHED`->`FIN_WAIT_1`] 客户端主动调用close时,向服务器发送结束报文段,同时进入`FIN_WAIT_1`;
 - [`FIN_WAIT_1`->`FIN_WAIT_2`] 客户端收到服务器对结束报文段的确认,则进入`FIN_WAIT_2`, 开始等待服务器的结束报文段;
 -  [`FIN_WAIT_2`->`TIME_WAIT`] 客户端收到服务器发来的结束报文段,进入`TIME_WAIT`, 并发出`LAST_ACK`;
 -  [`TIME_WAIT`->`CLOSED`] 客户端要等待一个`2MSL`(MaxSegmentLife,报文最大生存时间)的时间,才会进入`CLOSED`状态.

下图是TCP状态转换的一个汇总：
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/dbfe1a9c69ad4468b9382e6654a1ab4d.png)
- 为什么要进行三次握手？
	- 建立双方通信的意愿共识（要不要连接）
	- 双方验证全双工通信的流畅性(能不能连接）
	- 其中三次握手本质上也是四次挥手
	 ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a5598e48d41b470e87b6cee0d78de9eb.jpeg)
- 为什么是四次挥手？
	- 断开连接，是需要得到双方同意（因为是全双工通信） 。

- 三次挥手
	- 是双方操作系统自动完成的（与listen，accept无关）
	- 本质上就是在赌最后一个ACK对方收到了
- 四次挥手
	-    [`FIN_WAIT_2`->`TIME_WAIT`] 长时间未响应自动跳转
	-  [`TIME_WAIT`->`CLOSED`] 客户端要等待一个`2MSL`(MaxSegmentLife,报文最大生存时间)的时间,才会进入`CLOSED`状态.目的是为了游离在网络中的报文等待其消散；且尽可能确保四次挥手顺利进行



## 理解TIME_WAIT状态


现在做一个测试，首先启动server，然后启动client，然后用Ctrl-C使server终止，这时马上再运行server，结果是：
```
$./server
bind error: Address already in use
```
这是因为，虽然server的应用程序终止了，但TCP协议层的连接并没有完全断开，因此不能再次监听同样的server端端口。我们用netstat命令查看一下：
```
$ netstat -apn |grep 8000
tcp        1      0 127.0.0.1:33498         127.0.0.1:8000          CLOSE_WAIT  10830/client
tcp        0      0 127.0.0.1:8000          127.0.0.1:33498         FIN_WAIT2   -
```
- TCP协议规定，主动关闭连接的一方要处于TIME_WAIT状态，等待两个MSL(maximum segment lifetime)的时间后才能回到CLOSED状态。
- 我们使用Ctrl-C终止了server，所以server是主动关闭连接的一方，在TIME_WAIT期间仍然不能再次监听同样的server端端口；
- MSL在RFC1122中规定为两分钟，但是各操作系统的实现不同，在Centos7上默认配置的值是60s；
- 可以通过cat /proc/sys/net/ipv4/tcp_fin_timeout查看msl的值；
- 规定TIME_WAIT的时间请读者参考UNP 2.7节；
```
$ cat /proc/sys/net/ipv4/tcp_fin_timeout
60
```
想一想，为什么是TIME_WAIT的时间是2MSL？
- MSL是TCP报文的最大生存时间，因此TIME_WAIT持续存在2MSL的话就能保证在两个传输方向上的尚未被接收或迟到的报文段都已经消失(否则服务器立刻重启，可能会收到来自上一个进程的迟到的数据，但是这种数据很可能是错误的)；
- 同时也是**在理论上保证最后一个报文可靠到达**(假设最后一个ACK丢失，那么服务器会再重发一个FIN。这时虽然客户端的进程不在了，但是TCP连接还在，仍然可以重发LAST_ACK)；

### 解决TIME_WAIT状态引起的bind失败的方法
在server的TCP连接没有完全断开之前不允许重新监听，某些情况下可能是不合理的
- 服务器需要处理非常大量的客户端的连接(每个连接的生存时间可能很短，但是每秒都有很大数量的客户端来请求)。
- 这个时候如果由服务器端主动关闭连接(比如某些客户端不活跃，就需要被服务器端主动清理掉)，就会产生大量TIME_WAIT连接。
- 由于我们的请求量很大，就可能导致TIME_WAIT的连接数很多，每个连接都会占用一个通信五元组(源ip，源端口，目的ip，目的端口，协议)。其中服务器的ip和端口和协议是固定的。如果新来的客户端连接的ip和端口号和TIME_WAIT占用的链接重复了，就会出现问题。

使用setsockopt()设置socket描述符的选项SO_REUSEADDR为1，表示允许创建端口号相同但IP地址不同的多个socket描述符
```
int opt = 1;
setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
```

## 理解CLOSE_WAIT状态
以之前写过的TCP服务器为例，我们稍加修改
将new_sock.Close();这个代码去掉。
```cpp
#pragma once
#include <functional>
#include "tcp_socket.hpp"

typedef std::function<void (const std::string& req, std::string* resp)> Handler;

class TcpServer {
public:
    TcpServer(const std::string& ip, uint16_t port) : ip_(ip), port_(port) {}

    bool Start(Handler handler) {
        // 1. 创建socket
        CHECK_RET(listen_sock_.Socket());
        // 2. 绑定端口号
        CHECK_RET(listen_sock_.Bind(ip_, port_));
        // 3. 进行监听
        CHECK_RET(listen_sock_.Listen(5));
        // 4. 进入事件循环
        for (;;) {
            // 5. 进行accept
            TcpSocket new_sock;
            std::string ip;
            uint16_t port = 0;
            if (!listen_sock_.Accept(&new_sock, &ip, &port)) {
                continue;
            }
            printf("[client %s:%d] connect!\n", ip.c_str(), port);
            // 6. 进行循环读写
            for (;;) {
                std::string req;
                // 7. 读取请求，读取失败则结束循环
                bool ret = new_sock.Recv(&req);
                if (!ret) {
                    printf("[client %s:%d] disconnect!\n", ip.c_str(), port);
                    // [注意!] 将此处的关闭socket去掉
                    // new_sock.Close();
                    break;
                }
                // 8. 计算响应
                std::string resp;
                handler(req, &resp);
                // 9. 写回响应
                new_sock.Send(resp);
                printf("[%s:%d] req: %s, resp: %s\n", ip.c_str(), port, req.c_str(), resp.c_str());
            }
        }
        return true;
    }
private:
    TcpSocket listen_sock_;
    std::string ip_;
    uint64_t port_;
};
```
我们编译运行服务器。启动客户端链接，查看TCP状态，客户端服务器都为ESTABLISHED状态，没有问题。

然后我们关闭客户端程序，观察TCP状态
```
tcp        0      0 0.0.0.0:9090            0.0.0.0:*               LISTEN
tcp        0      0 127.0.0.1:4958          127.0.0.1:9090          TIME_WAIT
tcp        0      0 127.0.0.1:9090          127.0.0.1:4958          CLOSE_WAIT
```
此时服务器进入了CLOSE_WAIT状态，结合我们四次挥手的流程图，可以认为四次挥手没有正确完成。
小结：对于服务器上出现大量的CLOSE_WAIT状态，原因就是服务器没有正确的关闭socket，导致四次挥手没有正确完成。这是一个BUG，只需要加上对应的close即可解决问题。

## 滑动窗口
刚我们讨论了确认应答策略，对每一个发送的数据段，都要给一个ACK确认应答。这样做有一个比较大的缺点，就是性能较差，尤其是数据往返的时间较长的时候。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/15bd758189c9435db035ae44fc36315f.png)


既然这样一发一收的方式性能较低,那么我们一次发送多条数据,就可以大大的提高性能(其实是将多发一段的等待时间重叠在一起了)，一次发送多条数据，就可以大大的提高性能。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6e8f635fcf6145ffa596ab777db94200.png)

- 窗口大小指的是**无需等待确认应答而可以继续发送数据的最大值**（**对方可接受窗口大小**），上图的窗口大小就是4000个字节(四个段)
- 发送前四个段的时候，不需要等待任何ACK，直接发送；
- 收到第一个ACK后，滑动窗口向后移动，继续发送第五个段的数据；依次类推；
- 操作系统内核为了维护这个滑动窗口，需要开辟发送缓冲区来记录当前还有哪些数据没有应答；只有确认应答过的数据，才能从缓冲区删掉；
- 窗口越大，则网络的吞吐率就越高；
- 为什么要在窗口中一段一段发送数据？
	- 数据链路层不允许发送太大的报文 
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/75e130ee2769428eab833176f70e87ea.png)

那么如果出现了丢包，如何进行重传？这里分两种情况讨论。
情况一：数据包已经抵达，ACK被丢了。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/81d5c1ada3cd4b6fa481a8768d4ff97b.png)

这种情况下，部分ACK丢了并不要紧，因为可以通过后续的ACK进行确认；
情况二：数据包就直接丢了。 


![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/98ff40e68bb340daa6193f4ab2a873c0.png)

- 当某一段报文段丢失之后，发送端会一直收到1001这样的ACK，就像是在提醒发送端“我想要的是1001”一样；
- 如果发送端主机连续三次收到了同样一个“1001”这样的应答，就会将对应的数据1001 - 2000重新发送；

- 这个时候接收端收到了1001之后，再次返回的ACK就是7001了(因为2001 - 7000接收端其实之前就已经收到了，被放到了接收端操作系统内核的接收缓冲区中；
这种机制被称为“**高速重发控制**”(也叫“快重传”)。

## 流量控制


从客户端发送数据，如果服务器来不及接受数据呢？
- 流量控制机制（双方都要进行）
- 注意：控制！=减少发送

操作系统不做浪费时间，浪费空间的事情。但是有一点：客户端凭什么进行流量控制？怎么知道服务端来不及接收了？

- 确认应答中TCP报头的窗口大小！


接收端处理数据的速度是有限的。如果发送端发的太快，导致接收端的缓冲区被打满，这个时候如果发送端继续发送，就会造成丢包，继而引起丢包重传等等一系列连锁反应。
因此TCP支持根据接收端的处理能力，来决定发送端的发送速度。这个机制就叫做**流量控制**(Flow Control)；
- 接收端将自己可以接收的缓冲区大小放入TCP首部中的“窗口大小”字段，通过ACK端通知发送端；
- 窗口大小字段越大，说明网络的吞吐量越高；
- 接收端一旦发现自己的缓冲区快满了，就会将窗口大小设置成一个更小的值通知给发送端；
- 发送端接受到这个窗口之后，就会减慢自己的发送速度；
- 如果接收端缓冲区满了，就会将窗口置为0；这时发送方不再发送数据，但是需要定期发送一个窗口探测数据段，使接收端把窗口大小告诉发送端. 
- 6位标志位:
	- PSH: 提示接收端应用程序立刻从TCP缓冲区把数据读走
	- RST: 对方要求重新建立连接;我们把携带RST标识的称为复位报文段
	- URG: 紧急指针是否有效

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/95468eb94af64e0b8be7c58a8d467be8.png)
接收端如何把窗口大小告诉发送端呢？回忆我们的TCP首部中，有一个16位窗口字段，就是存放了窗口大小信息；
那么问题来了，16位数字最大表示65535，那么TCP窗口最大就是65535字节么？
实际上，TCP首部40字节选项中还包含了一个窗口扩大因子M，实际窗口大小是窗口字段的值左移M位;

## 拥塞控制
虽然TCP有了滑动窗口这个大杀器，能够高效可靠的发送大量的数据。但是如果在刚开始阶段就发送大量的数据，仍然可能引发问题.

因为网络上有很多的计算机，可能当前的网络状态就已经比较拥堵。在不清楚当前网络状态下，贸然发送大量的数据，是很有可能引起雪上加霜的.（如果发送数据的时候大量的报文丢失，发送端会判断网络会出现拥塞问题）

TCP引入**慢启动**机制，先发少量的数据，探探路，摸清当前的网络拥堵状态，再决定按照多大的速度传输数据; 

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6431326868af418b96cb5dfbd22f0b34.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e22c9be244a74f00b3635bc0a6b3e821.png)




- 当TCP开始启动的时候，慢启动阈值等于窗口最大值；
- 在每次超时重发的时候，慢启动阈值会变成原来的一半，同时拥塞窗口置回1；

少量的丢包，我们仅仅是触发超时重传；大量的丢包，我们就认为网络拥塞；
当TCP通信开始后，网络吞吐量会逐渐上升；随着网络发生拥堵，吞吐量会立刻下降；
拥塞控制，归根结底是TCP协议想尽可能快的把数据传输给对方，但是又要避免给网络造成太大压力的折中方案.




发送方可以同时发送的数据量，主要看两个方面：
- 滑动窗口大小
- 拥塞窗口大小

## 延迟应答
如果接收数据的主机立刻返回ACK应答，这时候返回的窗口可能比较小.
- 假设接收端缓冲区为1M. 一次收到了500K的数据；如果立刻应答，返回的窗口就是500K；
- 但实际上可能处理端处理的速度很快，10ms之内就把500K数据从缓冲区消费掉了；
- 在这种情况下，接收端处理还远没有达到自己的极限，即使窗口再放大一些，也能处理过来；
- 如果接收端稍微等一会再应答，比如等待200ms再应答，那么这个时候返回的窗口大小就是1M；


一定要记得，窗口越大，网络吞吐量就越大，传输效率就越高. 我们的目标是在保证网络不拥塞的情况下尽量提高传输效率；
那么所有的包都可以延迟应答么？肯定也不是；
- 数量限制：每隔N个包就应答一次；
- 时间限制：超过最大延迟时间就应答一次；

具体的数量和超时时间，依操作系统不同也有差异；一般N取2，超时时间取200ms；

## 捎带应答
在延迟应答的基础上，我们发现，很多情况下，客户端服务器在应用层也是“一发一收”的. 意味着客户端给服务器说了“How are you”，服务器也会给客户端回一个“Fine, thank you";
那么这个时候ACK就可以搭顺风车，和服务器回应的“Fine, thank you"一起回给客户端
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d01bce46268d42df878d63f139dd8f30.png)

## 面向字节流
创建一个TCP的socket，同时在内核中创建一个**发送缓冲区** 和一个**接收缓冲区**；
- 调用write时，数据会先写入发送缓冲区中；
- 如果发送的字节数太长，会被拆分成多个TCP的数据包发出；
- 如果发送的字节数太短，就会先在缓冲区里等待，等到缓冲区长度差不多了，或者其他合适的时机发送出去；
- 接收数据的时候，数据也是从网卡驱动程序到达内核的接收缓冲区；
- 然后应用程序可以调用read从接收缓冲区拿数据；
- 另一方面，TCP的一个连接，既有发送缓冲区，也有接收缓冲区，那么对于这一个连接，既可以读数据，也可以写数据，这个概念叫做**全双工**

由于缓冲区的存在，TCP程序的读和写不需要一一匹配，例如：
- 写100个字节数据时，可以调用一次write写100个字节，也可以调用100次write，每次写一个字节；
- 读100个字节数据时，也完全不需要考虑写的时候是怎么写的，既可以一次read 100个字节，也可以一次read一个字节，重复100次；

## 粘包问题

- 首先要明确，粘包问题中的“包”，是指的应用层的数据包.
- 在TCP的协议头中，没有如同UDP一样的“报文长度”这样的字段，但是有一个序号这样的字段.
- 站在传输层的角度，TCP是一个一个报文过来的. 按照序号排好序放在缓冲区中.
- 站在应用层的角度，看到的只是一串连续的字节数据.
- 那么应用程序看到了这么一连串的字节数据，就不知道从哪个部分开始到哪个部分是一个完整的应用层数据包.

那么如何避免粘包问题呢？归根结底就是一句话，明**确两个包之间的边界**.
- 对于**定长**的包，保证每次都按固定大小读取即可；例如上面的Request结构，是固定长度的，那么可以在包头的位置，约定一个包总长度的字段，从而就知道了包的结束位置；
- 对于变长的包，可以在包和包之间**使用明确的分隔符**(应用层协议，是程序猿自己来定的，只要保证分隔符不和正文冲突即可)；

对于UDP协议来说，是否也存在“粘包问题”呢？
- 对于UDP，如果还没有上层交付数据，UDP的报文长度仍然在. 同时，UDP是一个一个把数据交付给应用层的，有很明确的数据边界.
- 站在应用层的站在应用层的角度，使用UDP的时候，要么收到完整的UDP报文，要么不收. 不会出现“半个”的情况.

## TCP异常情况
进程终止：进程终止会释放文件描述符，仍然可以发送FIN. 和正常关闭没有什么区别.
机器重启：和进程终止的情况相同. 
机器掉电/网线断开：接收端认为连接还在，一旦接收端有写入操作，接收端发现连接已经不存在了，就会通过reset. 即使对方没有写入操作，TCP连接也内置了一个保活定时器，会定期询问对方是否还在. 如果对方不在，也会把连接释放. 
另外，应用层的某些协议，也有一些这样的检测机制. 例如HTTP长连接中，也会定期检测对方的状态. 例如QQ，在QQ断线之后，也会定期尝试重新连接. 

## TCP小结
为什么TCP这么复杂？因为要保证可靠性，同时又尽可能的提高性能.
### 可靠性
- 校验和
- 序列号(按序到达)
- 确认应答
- 超时重发
- 连接管理
- 流量控制
- 拥塞控制
### 提高性能
- 滑动窗口
- 快速重传
- 延迟应答
- 捎带应答
### 其他
- 定时器(超时重传定时器，保活定时器，TIME_WAIT定时器等)

## 基于TCP应用层协议
- HTTP
- HTTPS
- Telnet
- FTP
当然，也包括你自己写TCP程序时自定义的应用层协议；

## TCP/UDP对比
我们说了TCP是可靠连接，那么是不是TCP一定就优于UDP呢？TCP和UDP之间的优点和缺点，不能简单，绝对的进行比较
- TCP用于可靠传输的情况，应用于要求较高的通信领域，例如，早期的QQ，视频传输等. 另外TCP对系统资源要求较多；
- UDP用于对高速传输和实时性要求较高的通信领域，例如，早期的QQ，视频传输等. 另外UDP可以用于广播；
归根结底，TCP和UDP都是程序员的工具，什么时机用，具体怎么用，还是要根据具体的需求场景来判定. 

## 用UDP实现可靠传输(经典面试题)
参考TCP的可靠性机制，在应用层实现类似的逻辑；
- 引入序列号，保证数据顺序；
- 引入确认应答，确保对端收到了数据；
- 引入超时重传，如果一段时间没有应答，就重发数据；
- …… 


