# 传输层协议UDP
## 传输层
负责数据能够从发送端传输到接收端。

## 端口号
端口号(`Port`)标识了**一个主机上进行通信的不同的应用程序**。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6be78c321e47457aa2d211407f7e91bb.png)

在TCP/IP协议中，用“源IP”，“源端口号”，“目的IP”，“目的端口号”，“协议号”这样一个五元组来标识一个通信(可以通过netstat -n查看)。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/eb7d011eedf34fb9b77bbbac03340878.png)

### 端口号范围划分
- 0 - 1023：知名端口号，HTTP，FTP，SSH等这些广为使用的应用层协议，它们的端口号都是固定的。
- 1024 - 65535：操作系统动态分配的端口号。客户端程序的端口号，就是由操作系统从这个范围分配的。

### 认识知名端口号(Well-Know Port Number)
有些服务器是非常常用的，为了使用方便，人们约定一些常用的服务器，都是用以下这些固定的端口号：
- ssh服务器，使用22端口
- ftp服务器，使用21端口
- telnet服务器，使用23端口
- http服务器，使用80端口
- https服务器，使用443

执行下面的命令，可以看到知名端口号
```bash
cat /etc/services
```
我们自己写一个程序使用端口号时，要避开这些知名端口号。

## 两个问题
1. 一个进程是否可以bind多个端口号？
2. 一个端口号是否可以被多个进程bind？

## UDP协议
### UDP协议端格式
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/580a120ef9d941efb196d27e8f3cd5fe.png)

- 16位UDP长度，表示整个数据报(UDP首部+UDP数据)的最大长度；
- 如果校验和出错，就会直接丢弃；

### UDP的特点
UDP传输的过程类似于寄信。
- 无连接：知道**对端的IP和端口号就直接进行传输，不需要建立连接**；
- 不可靠：**没有确认机制，没有重传机制**；如果因为网络故障该段无法发到对方，UDP协议层也不会给应用层返回任何错误信息；
- 面向数据报：**不能够灵活的控制读写数据的次数和数量**；

### 面向数据报
应用层交给UDP多长的报文，UDP**原样发送，既不会拆分，也不会合并**；
- 如果发送端调用一次sendto，发送100个字节，那么接收端也必须调用对应的一次recvfrom，接收100个字节；而不能循环调用10次recvfrom，每次接收10个字节；

### UDP的缓冲区
- UDP没有真正意义上的**发送缓冲区**，调用sendto会直接交给内核，由内核将数据传给网络层协议进行后续的传输动作；
- UDP具有接收缓冲区，但是这个接**收缓冲区不能保证收到的UDP报的顺序和发送UDP报的顺序一致**；如果缓冲区满了，再到达的UDP数据就会被丢弃；（不可靠的特性：无法保证数据按顺序到达）
UDP的socket既能读，也能写，这个概念叫做**全双工**。

### UDP使用注意事项
我们注意到，UDP协议首部中有一个16位的最大长度，也就是说一个UDP能传输的数据最大长度是64K(包含UDP首部)。
然而64K在当今的互联网环境下，是一个非常小的数字。
如果我们需要传输的数据超过64K，就需要在应用层手动分包，多次发送，并在接收端进行组装。

### 基于UDP的应用层协议
- NFS：网络文件系统
- TFTP：简单文件传输协议
- DHCP：动态主机配置协议
- BOOTP：启动协议(用于无盘设备启动)
- DNS：域名解析协议

当然，也包括你自己写UDP程序时自定义的应用层协议。 
